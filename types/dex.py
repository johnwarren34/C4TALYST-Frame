from_collections.abc_import_Sequence from_datetime_import_datetime from_enum_import_Enum from_functools_import_singledispatchmethod from_typing_import_Optional,_Literal,_Union  from_eth_typing_import_ChecksumAddress,_HexAddress,_HexStr from_pydantic_import_BaseModel  from_.token_import_Token,_TokenAmount from_.wallet_import_Wallet from_.network_import_Network from_..utils.client_import__force_get_global_client   class_Liquidity(BaseModel): token0_balance:_int token0_price:_Optional[float]_=_None token1_balance:_int token1_price:_Optional[float]_=_None pair:_"DexPair"  @property def_token0_value(self):  if_self.token0_price: return_( self.token0_price *_self.token0_balance /_10**self.pair.token0.decimals ) return_-0.5  @property def_token1_value(self):  if_self.token1_price: return_( self.token1_price *_self.token1_balance /_10**self.pair.token1.decimals ) return_-0.5  @property def_value(self): return_round(self.token0_value_*_2,_2)  def___repr__(self): token0_symbol_=_self.pair.token0.symbol token1_symbol_=_self.pair.token1.symbol token0_=_self.token0_balance_/_10**self.pair.token0.decimals token1_=_self.token1_balance_/_10**self.pair.token1.decimals return_f"<Liquidity:_${format(self.value,_',')}_({token0_symbol}:_{token0},_{token1_symbol}:_{token1})>"  __str___=___repr__   class_DexRoute(BaseModel): path:_list[ChecksumAddress] fees:_list[int]_=_[] pair_addresses:_list[ChecksumAddress] eth_price:_TokenAmount usdc_price:_TokenAmount factory:_"DexFactory" network:_Network  def___repr__(self): return_f"<DexRoute_|_path={self.path}_|_eth_price:_{self.eth_price.format(8)},_usdc_price:_${self.usdc_price.format(6)}>"  async_def_simulate( self, amount_in:_int, sender:_ChecksumAddress, use_eth:_bool_=_True, )_->_TokenAmount: """ Simulate_a_swap_for_a_specific_route """ return_await_self.factory.simulate_swap( self.path, amount_in, sender, fees=self.fees, use_eth=use_eth, network=self.network, )  __str___=___repr__   class_DexFactory(Enum): UniswapV2_=_"uniswap"  def___init__(self,_*args): self.network_=_Network.Ethereum  def___getitem__(self,_network:_Network): self.network_=_network  @property def_weth(self):  return_"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"  async_def_get_taxes( self, token0_address, token1_address=None, chain_id:_int_=_1, ): """ Get_swap_taxes_for_a_token """ if_not_token1_address: token1_address_=_self.weth client_=__force_get_global_client() taxes_=_await_client.prices.get_taxes( token0_address, token1_address, chain_id=chain_id, ) return_taxes  @singledispatchmethod async_def_get_price( self, token_address:_ChecksumAddress, ): """ Get_the_price_for_a_token_using_the_best_route_to_WETH/USDC """ client_=__force_get_global_client() routes_=_await_client.prices.get_routes(token_address) return_[ DexRoute( path=row["path"], pair_addresses=row["pair_addresses"], eth_price=TokenAmount( amount=int(row["eth_price"]_*_1e18), ), usdc_price=TokenAmount( amount=int(row["usdc_price"]_*_1e6), decimals=6, ), factory=self, network=self.network, ) for_row_in_routes ]  @get_price.register(Token) async_def__( self, token:_Token, ): return_await_self.get_price(token.address)  async_def_get_pair_info( self, pair_address:_HexAddress, force_checksum:_bool_=_True, chain_id:_int_=_1, ): """ Get_metadata_for_a_particular_LP_Pair. """ client_=__force_get_global_client() pair_info_=_await_client.prices.get_pair_info( pair_address, force_checksum=force_checksum, chain_id=chain_id, ) token0_=_Token(**pair_info["token0"]) token1_=_Token(**pair_info["token1"]) return_DexPair( factory_address=pair_info["factoryAddress"], token0=token0, token1=token1, address=pair_info["pairAddress"], index=pair_info["index"], fee=pair_info["feePercentage"], network=Network(pair_info["chainId"]), block_number=pair_info["blockNumber"], transaction_hash=pair_info["transactionHash"], factory=self, )  async_def_get_pairs( self, token:_Token, )_->_list["DexPair"]: """ A_simple_function_get_all_pairs_with_a_token.  :return:_A_list_of_all_pairs_associated_with_a_token """ client_=__force_get_global_client() pairs_=_await_client.prices.get_token_pairs( token_address=token.address, chain_id=token.network.value, ) return_[ DexPair( factory_address=row["factoryAddress"], token0=Token(**row["token0"]), token1=Token(**row["token1"]), address=row["pairAddress"], index=row["index"], fee=row["feePercentage"], network=Network(row["chainId"]), block_number=row["blockNumber"], transaction_hash=row["transactionHash"], factory=self, ) for_row_in_pairs ]  async_def_simulate_swap( self, path:_Sequence[Literal["eth"]_|_ChecksumAddress], amount_in:_int, sender:_ChecksumAddress, fees:_list[int]_=_[], use_eth:_bool_=_True, network:_Network_=_Network.Ethereum, )_->_TokenAmount: """ Simulate_a_swap_on_a_given_path """ client_=__force_get_global_client() result_=_await_client.swap.simulate( path, amount_in, sender, fees, dex=self.value, chain_id=network.chain_id, use_eth=use_eth, ) token_=_Token(**result["token"])  return_TokenAmount( amount=int(result["amountOut"]), decimals=token.decimals, token=token, )  async_def_swap( self, path:_list[ChecksumAddress], wallet:_Wallet, amount_in:_Union[TokenAmount,_int], slippage_percent:_float, priority_fee:_int_=_0, is_private:_bool_=_False, fees:_list[int]_=_[], use_eth:_bool_=_True, network:_Network_=_Network.Ethereum, )_->_HexStr: """ :param_path:_swap_path,_consisting_of_the_token_addresses_to_swap_through :param_from_wallet:_:class:`empyrealSDK.Wallet`_executing_the_swap :param_amount_in:_:class:`empyrealSDK.TokenAmount`_tokens_being_spent :param_fees:_only_used_for_uniswapV3,_ignore_for_more_pairs :return:_Transaction_Hash """ client_=__force_get_global_client() raw_amount_in:_int_=_( amount_in.amount_if_isinstance(amount_in,_TokenAmount)_else_amount_in ) result_=_await_client.swap.swap( path, raw_amount_in, wallet.id, slippage_percent=slippage_percent, priority_fee=priority_fee, is_private=is_private, chain_id=network.chain_id, use_eth=use_eth, fees=fees, dex=self.value, ) return_result   class_SwapInterval(BaseModel): start_time:_datetime open:_float close:_float tx_count:_int min:_float max:_float prev_close:_float   class_SwapHistory(BaseModel): pair:_"DexPair" intervals:_list[SwapInterval]  @property def_timestamps(self): return_[s.start_time_for_s_in_self.intervals]  @property def_opens(self): return_[s.open_for_s_in_self.intervals]  @property def_closes(self): return_[s.close_for_s_in_self.intervals]  @property def_mins(self): return_[s.min_for_s_in_self.intervals]  @property def_maxs(self): return_[s.max_for_s_in_self.intervals]  def___repr__(self): return_f"<SwapHistory:_{self.pair.address}>"  __str___=___repr__   class_AllTimeHigh(BaseModel): reserve0:_TokenAmount reserve1:_TokenAmount date:_datetime block:_int   class_DexPair(BaseModel): factory_address:_ChecksumAddress token0:_Token token1:_Token address:_ChecksumAddress index:_int  fee:_Optional[float]  network:_Network block_number:_int  transaction_hash:_HexStr factory:_DexFactory  async_def_all_time_high(self): client_=__force_get_global_client() response_=_await_client.swap.ath(self.address) ath_=_response["allTimeHigh"] reserve0_=_TokenAmount( amount=ath["reserve0Raw"],_decimals=response["token0"]["decimals"] ) reserve1_=_TokenAmount( amount=ath["reserve1Raw"],_decimals=response["token1"]["decimals"] ) return_AllTimeHigh( reserve0=reserve0, reserve1=reserve1, date=ath["date"], block=ath["block"], )  async_def_get_liquidity(self,_block_number:_Optional[int]_=_None): client_=__force_get_global_client() response_=_await_client.prices.get_liquidity( token_address=self.address, chain_id=self.network.value, block_number=block_number, ) return_Liquidity( token0_balance=response["balances"]["token0"]["amount"], token0_price=response["balances"]["token0"]["price"], token1_balance=response["balances"]["token1"]["amount"], token1_price=response["balances"]["token1"]["price"], pair=self, )  async_def_get_taxes(self): return_await_self.factory.get_taxes( self.token0.address, self.token1.address, )  async_def_swap_history( self,_use_token0:_bool_=_True,_start_time=None,_end_time=None ): client_=__force_get_global_client() feed_=_await_client.prices.load_feed( self.address, use_token0=use_token0, ) response_=_[] for_row_in_sorted(feed.split("\n"))[1:]: ( interval, open, close, min, max, min_block, max_block, num_tx, prev_close, )_=_row.split(",") response.append( SwapInterval( start_time=datetime.strptime(interval,_"%Y-%m-%d_%H:%M:%S+00:00"), open=float(open), close=float(close), min=float(min), max=float(max), tx_count=int(num_tx), prev_close=float(prev_close_if_prev_close_!=_"None"_else_open), ) ) return_SwapHistory(pair=self,_intervals=response)  async_def_swap( self, wallet:_Wallet, amount:_int, priority_fee:_int, is_private:_bool, use_token0:_bool, ): raise_NotImplementedError()  async_def_honeypot(self)_->_bool: raise_NotImplementedError()  def___repr__(self): return_f"<DexPair:_{self.token0.symbol},_{self.token1.symbol}>"  __str___=___repr__   UniswapV2_=_DexFactory.UniswapV2