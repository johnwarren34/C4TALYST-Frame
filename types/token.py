from_functools_import_singledispatchmethod from_typing_import_Literal,_Optional,_Union from_uuid_import_UUID  from_eth_typing_import_ChecksumAddress,_HexStr from_pydantic_import_BaseModel,_Field  from_.network_import_Network from_.security_import_Security from_.wallet_import_Wallet from_..utils.client_import__force_get_global_client   class_Token(BaseModel): """An_abstraction_of_an_ERC20_token_instance"""  id:_UUID_=_Field() address:_ChecksumAddress name:_str symbol:_str decimals:_int network:_Network_=_Field(alias="chainId")  @classmethod async_def_load( cls, address:_ChecksumAddress, network:_Network_=_Network.Ethereum, ): client_=__force_get_global_client() response_=_await_client.token.lookup(address,_network.value) return_cls(**response.json())  async_def_allowance( self, owner:_ChecksumAddress, spender:_ChecksumAddress, block_num:_Optional[Union[int,_Literal["latest"]]]_=_"latest", )_->_"TokenAmount": """ Gets_the_allowance_allocated_to_an_address_from_a_spender   :param_owner:_A_checksummed_ethereum_address :param_spender:_A_checksummed_ethereum_address :return:_:class:`.TokenAmount` """ client_=__force_get_global_client() allowance_=_await_client.token.allowance( self.address, owner, spender, self.network.value, block_num=block_num, ) return_TokenAmount( amount=allowance, decimals=self.decimals, token=self, )  async_def_approve( self, from_wallet:_Wallet, spender:_Union[Wallet,_ChecksumAddress], amount:_int_=_int(2**256_-_1), priority_fee:_Optional[int]_=_None, )_->_HexStr: """ Approve_a_spender_to_use_a_token. :param_from_wallet:_:class:`empyrealSDK.Wallet`_making_the_approval :param_spender:_A_checksummed_ethereum_address :return:_HexStr  """ client_=__force_get_global_client() if_isinstance(spender,_Wallet): return_await_client.token.approve( self.id, from_wallet.id, spender.address, chain_id=self.network.chain_id, amount=amount, priority_fee=priority_fee, ) return_await_client.token.approve( self.id, from_wallet.id, spender, chain_id=self.network.chain_id, amount=amount, priority_fee=priority_fee, )  async_def_transfer( self, from_wallet:_Wallet, recipient:_Union[Wallet,_ChecksumAddress], amount:_"TokenAmount", gas_price:_Optional[int]_=_None, )_->_HexStr: """ Transfer_a_token_amount_to_a_target_address  :param_wallet:_:class:`empyrealSDK.Wallet` :param_recipient:_The_recipient_of_the_transfer :param_amount:_Amount_of_tokens_to_transfer :return:_HexStr_of_the_transaction """ client_=__force_get_global_client() if_isinstance(recipient,_Wallet): recipient_address_=_recipient.address else: recipient_address_=_recipient return_await_client.token.transfer( self.id, from_wallet.id, recipient_address, amount, gas_price=gas_price, )  @singledispatchmethod async_def_balance_of( self, wallet:_Wallet, block:_Union[int,_Literal["latest"]]_=_"latest", )_->_"TokenAmount": """ Gets_the_balance_of_a_wallet_at_a_particular_block. Defaults_to_latest_block.  :param_wallet:_:class:`empyrealSDK.Wallet` :param_block:_A_block_number_of_defaults_to_latest_block :return:_:class:`.TokenAmount`_of_the_current_balance """  client_=__force_get_global_client() balance_=_await_client.token.balance_of( self.address, wallet.address, self.network.value, block, ) return_TokenAmount(amount=balance,_decimals=self.decimals,_token=self)  async_def_security( self, ): client_=__force_get_global_client() security_=_await_client.token.security( self.id, self.network.value, ) return_Security(**security)  @balance_of.register(str) async_def__( self, wallet_address:_ChecksumAddress, network:_Network_=_Network.Ethereum, block:_Union[int,_Literal["latest"]]_=_"latest", ): """ Gets_the_balance_of_a_wallet_at_a_particular_block, given_a_Checksum_Address.  :param_wallet:_:class:`empyrealSDK.Wallet` :param_block:_A_block_number_of_defaults_to_latest_block :return:_:class:`.TokenAmount`_of_the_current_balance """  client_=__force_get_global_client() balance_=_await_client.token.balance_of( self.address, wallet_address, network.value, block, ) return_TokenAmount( amount=balance, decimals=self.decimals, token=self, )  def___repr__(self): return_f"<'{self.symbol}'_on_{self.network.name}>"  __str___=___repr__   class_TokenAmount(BaseModel): """An_abstraction_on_a_token_amount"""  amount:_int """The_raw_amount_of_tokens,_ignoring_the_decimal"""  decimals:_int_=_18 """The_number_of_decimals_used_onchain_to_represent_the_token_amount"""  token:_Optional["Token"]_=_None """The_token_associated_with_the_amount"""  def_format(self,_num_decimals=2): """Format_the_token_to_a_decimal_string,_with_respect_to_the_token_decimals""" return_round(self.amount_/_10**self.decimals,_num_decimals)  def___truediv__(self,_other): """Divide_the_token_by_either_another_TokenAmount_or_an_integer_value""" return_self._div_by_other(other)  def___mul__(self,_other): """Multiply_the_token_by_either_another_TokenAmount_or_an_integer_value""" return_self._mul_other(other)  @singledispatchmethod def__mul_other(self,_other:_int): return_TokenAmount( amount=self.amount_//_other, decimals=self.decimals, token=self.token, )  @singledispatchmethod def__div_by_other(self,_other:_int): return_TokenAmount( amount=self.amount_//_other, decimals=self.decimals, token=self.token, )  def___repr__(self): if_self.token: return_f"<{self.token.name}:_{self.amount_/_10**self.decimals}>" return_f"<Amount:_{self.amount_/_10**self.decimals}>"  __str___=___repr__   @TokenAmount._div_by_other.register(TokenAmount) def__(self:_TokenAmount,_other:_TokenAmount): return_TokenAmount( amount=int(self.amount_/_(other.amount_/_10**other.decimals)), decimals=self.decimals, token=self.token, )   @TokenAmount._mul_other.register(TokenAmount) def__(self:_TokenAmount,_other:_TokenAmount): return_TokenAmount( amount=int(int(self.amount_*_other.amount)_/_10**other.decimals), decimals=self.decimals, token=self.token, )